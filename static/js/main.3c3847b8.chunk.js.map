{"version":3,"sources":["actions/namesAction.ts","components/Autocomplete.tsx","hooks/usePrev.ts","hooks/useLocalStorage.ts","components/ListOfNames.tsx","App.tsx","reducers/namesReducer.ts","store/index.ts","index.tsx"],"names":["NamesActionTypes","Autocomplete","value","onChange","useState","string","setString","index","setIndex","description","prevString","ref","useRef","useEffect","current","usePrev","modification","split","randomTime","Math","random","array","length","setTimeout","str","Fragment","placeholder","type","useLocalStorage","key","initialValue","item","window","localStorage","getItem","JSON","parse","error","console","log","storedValue","setStoredValue","valueToStore","Function","setItem","stringify","ListOfNames","names","selectedNs","setSelectedNs","className","map","name","data-name","onClick","e","arr","target","dataset","pureNamesSet","Set","n","add","pureNames","Array","from","addHandler","filter","deleteHandler","App","ns","setNs","result","setResult","term","setTerm","dispatch","useDispatch","a","axios","response","FETCH_NAMES","data","preNames","useSelector","state","namesState","fetchedNames","splittedTerm","toUpperCase","includes","search","changeHandler","initialNamesState","rootReducer","combineReducers","action","store","createStore","applyMiddleware","thunk","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.3c3847b8.chunk.js","sourcesContent":["import axios from 'axios';\nimport { ActionCreator, Dispatch } from 'redux';\nimport { ThunkAction } from 'redux-thunk';\nimport { IName, INamesState } from '../reducers/namesReducer';\n\n\nexport enum NamesActionTypes {\n    FETCH_NAMES = 'FETCH_NAMES'\n}\n\nexport interface INamesGetAllAction {\n    type: NamesActionTypes.FETCH_NAMES;\n    names: IName[];\n}\n\nexport type NamesAction = INamesGetAllAction\n\nexport const getAllNames: ActionCreator<\nThunkAction<Promise<any>, INamesState, null, INamesGetAllAction>\n> = () => {\n    return async (dispatch: Dispatch) => {\n        try {\n            const response = await axios('https://jsonplaceholder.typicode.com/users');\n            dispatch({\n                type: NamesActionTypes.FETCH_NAMES,\n                names: response.data\n            });\n        } catch (err) {\n            console.log(err);\n        }\n    }\n}\nexport type getAllNamesAction = typeof getAllNames;\n","import React, { useState, useEffect } from 'react';\nimport '../style/main.scss';\nimport { usePrev } from '../hooks/usePrev';\n\ninterface IProps {\n    value: any;\n    onChange: any;\n}\nconst Autocomplete: React.FC<IProps> = ({ value, onChange }) => {\n    const [string, setString] = useState('');\n    const [index, setIndex] = useState(0);\n    const description = 'Aplikacja zaciąga userów, których lista jest następnie dostarczana do localStorage. Po kliknięciu na element wyrzucony z inputu, dodajemy ten element do drugiej listy. Usuwamy elementy z drugiej listy za pomocą kliknięcia w dany element. Jeśli chodzi o mechanizm szukania, wg założenia, żeby nie instalować dodatkowych bibliotek (chodzi mi o lodasha) użyłem starej, dobrej pętli for. Mogę powiedzieć, że wszystkie rozwiązania js-owe są moim pomysłem :)'\n    \n    const prevString = usePrev(string);\n    const modification = description.split('');\n   \n    const randomTime : number = Math.random() * (250-50) + 50;\n    const timeout = (array : any) => {\n        return setTimeout(()=>{\n\n            let str = string + array[index]\n            setIndex(index+1)\n            setString(str)\n        },randomTime)\n    }\nuseEffect(() => {\n    if (prevString !== string && index < modification.length){\n        timeout(modification)\n    } \n})\n\n\n    return (\n        <React.Fragment>\n            <form>\n                <input\n                    placeholder=\"name\"\n                    type=\"text\"\n                    value={value}\n                    onChange={onChange}\n                />\n            </form>\n            <article>\n                <h3>Opis działania:</h3>\n                <h4>\n                    {description}\n                </h4>\n            </article>\n        </React.Fragment>\n    )\n}\nexport default Autocomplete;","import { useEffect, useRef } from 'react'\n\nexport const usePrev = (value: string) => {\n    // The ref object is a generic container whose current property is mutable ...\n    // ... and can hold any value, similar to an instance property on a class\n    const ref : any = useRef();\n    \n    // Store current value in ref\n    useEffect(() => {\n      ref.current = value;\n    }, [value]); // Only re-run if value changes\n    \n    // Return previous value (happens before update in useEffect above)\n    return ref.current;\n  }","import { useState } from 'react';\n\nexport function useLocalStorage<T>(key: string, initialValue: T) {\n    // State to store our value\n    // Pass initial state function to useState so logic is only executed once\n    const [storedValue, setStoredValue] = useState<T>(() => {\n      try {\n        // Get from local storage by key\n        const item = window.localStorage.getItem(key);\n        // Parse stored json or if none return initialValue\n        return item ? JSON.parse(item) : initialValue;\n      } catch (error) {\n        // If error also return initialValue\n        console.log(error);\n        return initialValue;\n      }\n    });\n  \n    // Return a wrapped version of useState's setter function that ...\n    // ... persists the new value to localStorage.\n    const setValue = (value: T | ((val: T) => T)) => {\n      try {\n        // Allow value to be a function so we have same API as useState\n        const valueToStore =\n          value instanceof Function ? value(storedValue) : value;\n        // Save state\n        setStoredValue(valueToStore);\n        // Save to local storage\n        window.localStorage.setItem(key, JSON.stringify(valueToStore));\n      } catch (error) {\n        // A more advanced implementation would handle the error case\n        console.log(error);\n      }\n    };\n  \n    return [storedValue, setValue];\n  }","import React from \"react\";\nimport { IOnlyName } from '../App';\nimport '../style/main.scss';\nimport { useLocalStorage } from '../hooks/useLocalStorage';\n\ninterface IProps {\n  names: IOnlyName[];\n}\n\n\nconst ListOfNames: React.FC<IProps> = ({ names }) => {\n\n  const [selectedNs, setSelectedNs] = useLocalStorage<any>('selected', [])\n\n  const addHandler = (e: any): void => {\n    const arr: any = [...selectedNs, e.target.dataset.name]\n    const pureNamesSet = new Set();\n    arr.map((n : string) => pureNamesSet.add(n));\n    const pureNames : any = Array.from(pureNamesSet);\n    console.log(pureNames)\n    setSelectedNs(pureNames)\n  }\n  const deleteHandler = (e: any): void => {\n    setSelectedNs(selectedNs.filter((n: string )=> n !== e.target.dataset.name))\n  }\n  return (\n    <div className=\"results-container\">\n      <div className=\"results-list\">\n        {names.map((name) => (\n          <div data-name={`${name}`} onClick={(e) => addHandler(e)} key={`resultName-${name}`}>\n            {name}\n          </div>\n        ))\n        }\n      </div>\n      <div className=\"results-added-names\">\n        {selectedNs.map((name :string, index : number) => (\n          <div data-name={`${name}`} onClick={(e) => deleteHandler(e)} key={`selName-${name}`}>\n            {name}\n          </div>\n        ))}\n      </div>\n\n    </div>\n  );\n};\nexport default ListOfNames;\n","import React, { useState, useEffect } from \"react\";\nimport Autocomplete from \"./components/Autocomplete\";\nimport { getAllNames } from \"./actions/namesAction\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport ListOfNames from \"./components/ListOfNames\";\nimport { INamesState } from './reducers/namesReducer';\nimport { IAppState } from './store';\nimport { useLocalStorage } from './hooks/useLocalStorage';\n\nexport interface IOnlyName {\n  name?: string;\n  toUpperCase: any;\n  indexOf: any;\n}\n\nconst App: React.FC = () => {\n\n  const [ns, setNs] = useLocalStorage<any>('names', []);\n  const [result, setResult] = useState([]);\n  const [term, setTerm] = useState(\"\");\n\n  const dispatch = useDispatch();\n\n  useEffect((): void => {\n\n    if (ns.length > 0) {\n      return;\n    } else {\n      dispatch(getAllNames());\n    }\n  }, []);\n\n  const preNames: INamesState = useSelector((state: IAppState) => state.namesState);\n  useEffect(() => {\n    if (ns.length > 0) {\n      return;\n    } else {\n      const fetchedNames: string[] = preNames && preNames.names && preNames.names.map(n => n.name);\n      setNs(fetchedNames)\n    }\n  })\n  const changeHandler = (e: any) => {\n    setTerm(e.target.value);\n    let splittedTerm : any = e.target.value.toUpperCase().split(' ');\n    if (splittedTerm.length < 1) {\n      console.log(1)\n      setResult([]);\n    } else if(splittedTerm.length < 2 ) {\n      const arr = ns.filter((n : string) =>  n.toUpperCase().includes(splittedTerm[0]) ?\n      n : null )\n      setResult(arr);\n      console.log(splittedTerm)\n    } else if (splittedTerm.length > 1 && splittedTerm[1] !== '') {\n      const arr = ns.filter((n : string) =>  n.toUpperCase().search(splittedTerm[0]) > -1 && n.toUpperCase().search(splittedTerm[1]) > -1 ?\n      n : null)\n      console.log(splittedTerm)\n      setResult(arr)\n    }\n    }\n  return (\n    <div>\n      <main>\n        <Autocomplete onChange={(e: any) => changeHandler(e)} value={term} />\n        <ListOfNames names={result} />\n      </main>\n    </div>\n  );\n};\n\nexport default App;\n","import { NamesAction, NamesActionTypes } from '../actions/namesAction';\nimport { Reducer } from 'redux';\n\n\nexport interface IName {\n    id: number;\n    name: string;\n}\nexport interface INamesState {\n    names: IName[];\n}\n\nconst initialNamesState: INamesState = {\n    names: []\n  };\n\nexport const namesReducer: Reducer<INamesState, NamesAction> = ( state = initialNamesState, action ) => {\n    switch (action.type) {\n        case NamesActionTypes.FETCH_NAMES: {\n            return {\n                ...state,\n                names: action.names\n            }\n        }\n        default:\n            return state;\n    }\n}\nexport type RootState = typeof namesReducer","import { applyMiddleware, combineReducers, createStore, Store } from 'redux';\nimport thunk from 'redux-thunk';\nimport { namesReducer, INamesState } from '../reducers/namesReducer';\n\nexport interface IAppState {\n   namesState : INamesState\n}\n\nconst rootReducer = combineReducers<IAppState>({\n    namesState: namesReducer\n});\n\nexport default function configureStore(): Store<IAppState, any> {\n    const store = createStore(rootReducer, applyMiddleware(thunk));\n    return store;\n}","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./style/main.scss\";\nimport App from \"./App\";\nimport { Provider } from \"react-redux\";\nimport configureStore from \"./store\";\n\n// import { getAllNames } from \"./actions/namesAction\";\nconst store = configureStore();\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById(\"root\")\n);\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n// reportWebVitals();\n"],"sourceRoot":""}