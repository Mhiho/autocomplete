{"version":3,"sources":["actions/namesAction.ts","components/Autocomplete.tsx","hooks/usePrev.ts","components/ListOfNames.tsx","App.tsx","reducers/namesReducer.ts","store/index.ts","index.tsx"],"names":["NamesActionTypes","Autocomplete","value","onChange","useState","string","setString","index","setIndex","prevString","ref","useRef","useEffect","current","usePrev","modification","split","randomTime","Math","random","array","length","setTimeout","str","console","log","Fragment","placeholder","type","ListOfNames","names","selected","setSelected","className","map","name","data-name","onClick","e","arr","target","dataset","pureNamesSet","Set","n","add","pureNames","Array","from","addHandler","filter","deleteHandler","App","result","setResult","term","setTerm","JSON","parse","localStorage","getItem","dispatch","useDispatch","a","axios","response","FETCH_NAMES","data","preNames","useSelector","state","namesState","fetchedNames","setItem","stringify","ns","search","splitT","w","obj","i","j","toUpperCase","indexOf","delete","res","changeHandler","initialNamesState","rootReducer","combineReducers","action","store","createStore","applyMiddleware","thunk","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.a34a04c0.chunk.js","sourcesContent":["import axios from 'axios';\nimport { ActionCreator, Dispatch } from 'redux';\nimport { ThunkAction } from 'redux-thunk';\nimport { IName, INamesState } from '../reducers/namesReducer';\n\n\nexport enum NamesActionTypes {\n    FETCH_NAMES = 'FETCH_NAMES'\n}\n\nexport interface INamesGetAllAction {\n    type: NamesActionTypes.FETCH_NAMES;\n    names: IName[];\n}\n\nexport type NamesAction = INamesGetAllAction\n\nexport const getAllNames: ActionCreator<\nThunkAction<Promise<any>, INamesState, null, INamesGetAllAction>\n> = () => {\n    return async (dispatch: Dispatch) => {\n        try {\n            const response = await axios('https://jsonplaceholder.typicode.com/users');\n            dispatch({\n                type: NamesActionTypes.FETCH_NAMES,\n                names: response.data\n            });\n        } catch (err) {\n            console.log(err);\n        }\n    }\n}\nexport type getAllNamesAction = typeof getAllNames;\n","import React, { useState, useEffect } from 'react';\nimport '../style/main.scss';\nimport { usePrev } from '../hooks/usePrev'\n\ninterface IProps {\n    value: any;\n    onChange: any;\n}\nconst Autocomplete: React.FC<IProps> = ({ value, onChange }) => {\n    const [string, setString] = useState('');\n    const [index, setIndex] = useState(0);\n    const description = 'Aplikacja zaciąga userów, których lista jest następnie dostarczana do localStorage. Po kliknięciu na element wyrzucony z inputu, dodajemy ten element do drugiej listy. Usuwamy elementy z drugiej listy za pomocą kliknięcia w dany element. Jeśli chodzi o mechanizm szukania, wg założenia, żeby nie instalować dodatkowych bibliotek (chodzi mi o lodasha) użyłem starej, dobrej pętli for. Mogę powiedzieć, że wszystkie rozwiązania js-owe są moim pomysłem :)'\n    \n    const prevString = usePrev(string);\n    const modification = description.split('');\n   \n    const randomTime : number = Math.random() * (250-50) + 50;\n    const timeout = (array : any) => {\n        return setTimeout(()=>{\n\n            let str = string + array[index]\n            setIndex(index+1)\n            setString(str)\n            console.log(string)\n        },randomTime)\n    }\nuseEffect(() => {\n    if (prevString !== string && index < modification.length){\n        timeout(modification)\n    } \n})\n\n\n    return (\n        <React.Fragment>\n            <form>\n                <input\n                    placeholder=\"name\"\n                    type=\"text\"\n                    value={value}\n                    onChange={onChange}\n                />\n            </form>\n            <article>\n                <h3>Opis działania:</h3>\n                <h4>\n                    {string}\n                </h4>\n            </article>\n        </React.Fragment>\n    )\n}\nexport default Autocomplete;","import { useEffect, useRef } from 'react'\n\nexport const usePrev = (value: string) => {\n    // The ref object is a generic container whose current property is mutable ...\n    // ... and can hold any value, similar to an instance property on a class\n    const ref : any = useRef();\n    \n    // Store current value in ref\n    useEffect(() => {\n      ref.current = value;\n    }, [value]); // Only re-run if value changes\n    \n    // Return previous value (happens before update in useEffect above)\n    return ref.current;\n  }","import React, { useState } from \"react\";\nimport { IOnlyName } from '../App';\nimport '../style/main.scss';\n\ninterface IProps {\n  names: IOnlyName[];\n}\n\n\nconst ListOfNames: React.FC<IProps> = ({ names }) => {\n\n  const [selected, setSelected] = useState([]);\n\n  const addHandler = (e: any): void => {\n    const arr: any = [...selected, e.target.dataset.name]\n    const pureNamesSet = new Set();\n    arr.map((n : string) => pureNamesSet.add(n));\n    const pureNames : any = Array.from(pureNamesSet);\n    console.log(pureNames)\n    setSelected(pureNames)\n  }\n  const deleteHandler = (e: any): void => {\n    setSelected(selected.filter(n => n !== e.target.dataset.name))\n  }\n  return (\n    <div className=\"results-container\">\n      <div className=\"results-list\">\n        {names.map((name) => (\n          <div data-name={`${name}`} onClick={(e) => addHandler(e)} key={`resultName-${name}`}>\n            {name}\n          </div>\n        ))\n        }\n      </div>\n      <div className=\"results-added-names\">\n        {selected.map((name, index) => (\n          <div data-name={`${name}`} onClick={(e) => deleteHandler(e)} key={`selName-${name}`}>\n            {name}\n          </div>\n        ))}\n      </div>\n\n    </div>\n  );\n};\nexport default ListOfNames;\n","import React, { useState, useEffect } from \"react\";\nimport Autocomplete from \"./components/Autocomplete\";\nimport { getAllNames } from \"./actions/namesAction\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport ListOfNames from \"./components/ListOfNames\";\nimport { IName, INamesState } from './reducers/namesReducer';\nimport { IAppState } from './store';\n\nexport interface IOnlyName {\n  name ? : string;\n  toUpperCase: any;\n  indexOf: any;\n}\n\nconst App : React.FC = () => {\n\n  const [result, setResult] = useState([]);\n  const [term, setTerm] = useState(\"\");\n  const names : any = JSON.parse(localStorage.getItem('names') || '{}')\n  const dispatch = useDispatch();\n  useEffect(() : void => {\n    if(names.length > 0){\n      return;\n    }else{\n      dispatch(getAllNames());\n    }\n    }, [dispatch,names]); \n    \n  const preNames : INamesState = useSelector((state : IAppState) => state.namesState);\n  const fetchedNames : string[] = preNames && preNames.names && preNames.names.map((n : IName) => n.name);\n  localStorage.setItem('names', JSON.stringify(fetchedNames))\n  const ns : string[] = names || fetchedNames;\n  console.log(fetchedNames) \n  console.log(ns)\n  const changeHandler = (e : any) => {\n    setTerm(e.target.value);\n    if (e.target.value === \"\") {\n      setResult([]);\n    } else if (term.search(/\\s/)) {\n      const presplitT = e.target.value.split(/\\s/);\n      const splitT : IOnlyName[] = presplitT.filter((w: IOnlyName[\"name\"]) => w !== \"\");\n      const obj = new Set();\n      console.log(splitT);\n      for (let i = 0; i < ns.length; i++) {\n        for (let j = 0; j < splitT.length; j++) {\n          if (ns[i].toUpperCase().indexOf(splitT[j].toUpperCase()) > -1) {\n            obj.add(ns[i]);\n          } else {\n            obj.delete(ns[i]);\n          }\n        }\n      }\n      const arr : any = Array.from(obj);\n      setResult(arr);\n    } else {\n      const res : any = ns.filter((name: any) =>\n        name.toUpperCase().indexOf(e.target.value.toUpperCase()) > -1\n          ? name\n          : null\n      );\n      setResult(res);\n    }\n  };\n  return (\n    <div>\n      <main>\n        <Autocomplete onChange={( e : any ) => changeHandler(e)} value={term} />\n        <ListOfNames names={result} />\n      </main>\n    </div>\n  );\n};\n\nexport default App;\n","import { NamesAction, NamesActionTypes } from '../actions/namesAction';\nimport { Reducer } from 'redux';\n\n\nexport interface IName {\n    id: number;\n    name: string;\n}\nexport interface INamesState {\n    names: IName[];\n}\n\nconst initialNamesState: INamesState = {\n    names: []\n  };\n\nexport const namesReducer: Reducer<INamesState, NamesAction> = ( state = initialNamesState, action ) => {\n    switch (action.type) {\n        case NamesActionTypes.FETCH_NAMES: {\n            return {\n                ...state,\n                names: action.names\n            }\n        }\n        default:\n            return state;\n    }\n}\nexport type RootState = typeof namesReducer","import { applyMiddleware, combineReducers, createStore, Store } from 'redux';\nimport thunk from 'redux-thunk';\nimport { namesReducer, INamesState } from '../reducers/namesReducer';\n\nexport interface IAppState {\n   namesState : INamesState\n}\n\nconst rootReducer = combineReducers<IAppState>({\n    namesState: namesReducer\n});\n\nexport default function configureStore(): Store<IAppState, any> {\n    const store = createStore(rootReducer, applyMiddleware(thunk));\n    return store;\n}","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./style/main.scss\";\nimport App from \"./App\";\nimport { Provider } from \"react-redux\";\nimport configureStore from \"./store\";\n\n// import { getAllNames } from \"./actions/namesAction\";\nconst store = configureStore();\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById(\"root\")\n);\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n// reportWebVitals();\n"],"sourceRoot":""}